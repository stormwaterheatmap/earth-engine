/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var image2 = ee.Image("users/cnilsen/Marshlands/snohoco_southwest_2003_dtm_12"),
    imageCollection = ee.ImageCollection("USDA/NAIP/DOQQ"),
    imageCollection2 = ee.ImageCollection("USDA/NASS/CDL"),
    cdl2016 = ee.Image("USDA/NASS/CDL/2016"),
    imageVisParam = {"opacity":1,"bands":["cluster"],"min":0,"max":5,"palette":["006600","008000","667062","3d3d3d","73b343","4aaf38"]},
    imageVisParam2 = {"opacity":0.67,"bands":["nd"],"palette":["219750"]},
    imageVisParam3 = {"opacity":0.64,"bands":["nd"],"palette":["a3a3a3"]},
    tiger = ee.FeatureCollection("TIGER/2016/Roads"),
    imageCollection3 = ee.ImageCollection("USGS/NLCD"),
    imageVisParam4 = {"opacity":1,"bands":["nd"],"min":0,"max":0.8,"palette":["a16928","bd925a","d6bd8d","edeac2","b5c8b8","79a7ac","2887a1"]},
    DTM = ee.Image("users/stormwaterheatmap/lidar/kingcounty_delivery1_be"),
    DSM = ee.Image("users/stormwaterheatmap/lidar/kingcounty_delivery1_hh"),
    imageVisParam5 = {"opacity":1,"bands":["b1"],"min":-2.8941713895640568e+37,"max":3.071968962003652e+37,"palette":["f7feae","b7e6a5","7ccba2","46aea0","089099","00718b","045275"]},
    imageVisParam6 = {"opacity":1,"bands":["b1"],"min":3.3895306812168547e+37,"max":3.050577613095169e+38,"gamma":1},
    geometry = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-122.34789427503722, 47.508026814701445],
          [-122.34789427503722, 47.425401908034765],
          [-122.17039641126769, 47.425401908034765],
          [-122.17039641126769, 47.508026814701445]]], null, false),
    ghsl = ee.Image("JRC/GHSL/P2016/BUILT_LDSMT_GLOBE_V1"),
    table = ee.FeatureCollection("users/stormwaterheatmap/MS4_bounds"),
    table2 = ee.FeatureCollection("TIGER/2010/Blocks"),
    image = ee.Image("users/stormwaterheatmap/predictors_convolved"),
    image3 = ee.Image("users/stormwaterheatmap/landcover_5m"),
    NLCD = ee.ImageCollection("USGS/NLCD"),
    impYear = ee.Image("Tsinghua/FROM-GLC/GAIA/v10");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
//ID Trees from Lidar and NDVI
//specific for OGD
var PS_AU = ee.FeatureCollection(
    'users/cnilsen/PS_AU')
var ws_bounds = PS_AU.reduceToImage(['AU_ID'], ee.Reducer.first())
var NLCD = ee.Image("USGS/NLCD/NLCD2016").select('landcover')
Map.addLayer(NLCD)
var census = table2.reduceToImage(['pop10'],ee.Reducer.mean())
Map.addLayer(census)

//take the difference of the dsm and dtm 
//!idea smooth before taking difference
//DTM (be) is in meters
DTM = DTM.multiply(3.280839895) //convert everything to feet
var diff = DSM.subtract(DTM); 
Map.addLayer(diff,{},'diff',0);  
//ERODE difference layer to get rid of small patches 
var kernel = ee.Kernel.circle({radius: 1});
var opened = diff
             .focal_min({kernel: kernel, iterations: 2})
             .focal_max({kernel: kernel, iterations: 2});

var opened = opened.gt(10); //only keep differences over a certain height threshold
Map.addLayer(opened, {}, 'opened',0);

//Map.centerObject(geometry)


// //functions 
// var palette = ee.List.sequence(0, 254).map(function(n) {

//   var index = ee.List(cdl2016.get("cropland_class_values")).indexOf(n)
//   return ee.Algorithms.If(ee.Algorithms.IsEqual(index, -1), 
//       "000000", 
//       ee.List(cdl2016.get("cropland_class_palette")).get(index))
// }).getInfo()

//functions for eroding and dialating

function erode(img, distance) {
  var d = (img.not().unmask(1)
       .fastDistanceTransform(30).sqrt()
       .multiply(ee.Image.pixelArea().sqrt()))
  return img.updateMask(d.gt(distance))
}
function dilate(img, distance) {
  var d = (img.fastDistanceTransform(30).sqrt()
       .multiply(ee.Image.pixelArea().sqrt()))
  return d.lt(distance)
}
function expandSeeds(seeds) {
  seeds = seeds.unmask(0).focal_max()
  return seeds.updateMask(seeds)
}
//get NAIP Data

var bands = ["R", "G", "B", "N"]
var img = imageCollection
    .filterDate('2015-01-01', '2019-01-01')
    .filterBounds(geometry)
    .mosaic()
img = ee.Image(img).divide(255).select(bands)
Map.addLayer(img, {gamma: 0.8}, "RGBN", false)
//var img = img.mask(opened).clip(geometry);

//--------begin segmentation 
// define seeds 
var seeds = ee.Algorithms.Image.Segmentation.seedGrid(16,'hex');
var seeds = seeds.mask(opened); 

// Build and train a classifer using point values from the seed locations.
//var points = img.addBands(cdl2016).updateMask(seeds).sample(geometry, 5); 
//var points = img.addBands(cdl2016).sample(geometry, 5); 
//var classifier = ee.Classifier.randomForest(10).train(points, "cropland")
//Map.addLayer(img.classify(classifier), {min:0, max:254, palette: palette}, "Classified image", false)
// Apply a softening.
//var kernel = ee.Kernel.gaussian(3)
//img = img.convolve(kernel)
//Map.addLayer(img, {gamma: 0.8}, "RGBN blur", false)
// Compute and display NDVI, NDVI slices and NDVI gradient.
var ndvi = img.normalizedDifference(["N", "R"])
// print(ui.Chart.image.histogram(ndvi, geometry, 10))
//Map.addLayer(ndvi, {min:0, max:1, palette: ["black", "tan", "green", "darkgreen"]}, "NDVI", false)
//Map.addLayer(ndvi.gt([0, 0.2, 0.40, 0.60, 0.80, 1.00]).reduce('sum'), {min:0, max: 6}, "NDVI steps", false)
var ndviGradient = ndvi.gradient().pow(2).reduce('sum').sqrt()
var slopeGradient = ndvi.gradient().pow(2).reduce('sum').sqrt()
//Map.addLayer(ndviGradient, {min:0, max:0.01}, "NDVI gradient", false)

// Compute spectralGradients.

var gradient3 = ee.Image.cat(
  img.spectralGradient('sam'),
  img.spectralGradient('sid'),
  img.spectralGradient('sed'))
//Map.addLayer(gradient3, {min:[0.1, 0.1, 0.01], max:[0.3, 0.3, 0.1]}, "gradient3", false)
var gradient = img.spectralErosion().spectralGradient('emd')
Map.addLayer(gradient, {min:0, max: 0.3}, "emd", false)
Map.addLayer(gradient3, {min:0, max: 0.3}, "gradient3", false)



var snicImage = img.addBands(gradient)

var snic = ee.Algorithms.Image.Segmentation.SNIC({
  image: snicImage, 
  size: 8,
  compactness: 2,
  connectivity: 8,
  neighborhoodSize:256,
  seeds: seeds
})//.select(["R_mean", "G_mean", "B_mean", "N_mean", "clusters"], ["R", "G", "B", "N", "clusters"])
var clusters = snic.select("clusters")
Map.addLayer(clusters.randomVisualizer(), {}, "clusters",0)
//Map.addLayer(snic, {bands: ["R", "G", "B"], min:0, max:1, gamma: 0.8}, "means")
Map.addLayer(snic, {}, "snicAll")
//calculate NDVI of snic 
var snicNDVI = snic.normalizedDifference(["N_mean", "R_mean"]); 

var histogram = snicNDVI.reduceRegion({
  reducer: ee.Reducer.histogram(255)
      .combine('mean', null, true)
      .combine('variance', null, true), 
  geometry: geometry, 
  scale: 5,
  bestEffort: true
});
//print(Chart.image.histogram(snicNDVI, 30));


//implement otsu thresholding 
var otsu = function(histogram) {
  var counts = ee.Array(ee.Dictionary(histogram).get('histogram'));
  var means = ee.Array(ee.Dictionary(histogram).get('bucketMeans'));
  var size = means.length().get([0]);
  var total = counts.reduce(ee.Reducer.sum(), [0]).get([0]);
  var sum = means.multiply(counts).reduce(ee.Reducer.sum(), [0]).get([0]);
  var mean = sum.divide(total);
  
  var indices = ee.List.sequence(1, size);
  
  // Compute between sum of squares, where each mean partitions the data.
  var bss = indices.map(function(i) {
    var aCounts = counts.slice(0, 0, i);
    var aCount = aCounts.reduce(ee.Reducer.sum(), [0]).get([0]);
    var aMeans = means.slice(0, 0, i);
    var aMean = aMeans.multiply(aCounts)
        .reduce(ee.Reducer.sum(), [0]).get([0])
        .divide(aCount);
    var bCount = total.subtract(aCount);
    var bMean = sum.subtract(aCount.multiply(aMean)).divide(bCount);
    return aCount.multiply(aMean.subtract(mean).pow(2)).add(
           bCount.multiply(bMean.subtract(mean).pow(2)));
  });
  
  //print(ui.Chart.array.values(ee.Array(bss), 0, means));
  
  // Return the mean value corresponding to the maximum BSS.
  return means.sort(bss).get([-1]);
};

var hist = snicNDVI.reduceRegion(ee.Reducer.histogram(),geometry); 

//print(histogram); 
var threshold = otsu(histogram.get('nd_histogram'));
print('threshold', threshold);

var roofs = snicNDVI.lte(threshold); 
var trees = snicNDVI.gt(threshold);

Map.addLayer(roofs.mask(roofs),imageVisParam3,'roofs'); 
Map.addLayer(trees.mask(trees),imageVisParam2,'trees'); 

var aspect=ee.Algorithms.Terrain(ee.Image("CGIAR/SRTM90_V4").focal_mean()).select('aspect').divide(2)
var NHD = ee.FeatureCollection(
    'users/cnilsen/PugetSoundNHDPlusWatersheds');
print(NHD.first())
var NHD = NHD.reduceToImage(['GRIDCODE'],ee.Reducer.first())//.subtract(505191).divide(17767)

var vizParam =  {"opacity":1,"bands":["b1"],"min":10,"max":100,"gamma":1};
Map.addLayer(diff.mask(trees).mask(diff.gt(10)),vizParam,'diff mask')
//make idea watersheds 
var built = ghsl.select('built').subtract(1).divide(5)
// combine year of development, ndvi, and delineated ws 
var compImg = ee.Image.cat(//ndvi,//aspect.focal_mean(),
NHD,built)
Map.addLayer(compImg,{},'compImg')
//slopeGradient)//,NLCD.resample().focal_mean())
//var wsSeeds = ee.Algorithims.seeds
var snicWS =ee.Algorithms.Image.Segmentation.SNIC({image:compImg, size:100, compactness:256})
Map.addLayer(snicWS.select('clusters').randomVisualizer())
print(compImg.reduceRegion(ee.Reducer.minMax(), geometry, 30))//, crs, crsTransform, bestEffort, maxPixels, tileScale)
